## 목차  
[Spring DI/IOC는 어떻게 동작하는가?](#1)

## <a id="1">Spring DI/IOC는 어떻게 동작하는가?</a>
### IoC(제어의 역전)
> 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것. 코드의 최종 호출을 개발자가 아닌 프레임워크 내부에서 결정된 대로 이뤄짐

- 내 생각: 내가 일일히 의존성주입 안해줘도 됨 객체 생명주기 관리 안해줘도 되고 내가 하면 실수 연발일 듯
- 모듈화 가능?

### DI(의존성 주입)
> 스프링에서 지원하는 IoC의 형태. 클래스 사이 의존관계를 빈 설정 정보 바탕으로 컨테이너가 자동으로 연결

## <a id="2">Spring Bean이란 무엇인가?</a>
> IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC 컨테이너에서 가져와서 사용  

`@Bean`을 사용해서 일반 객체를 Bean으로 등록 가능

## <a id="3">Bean의 생성 과정을 설명하라</a>
> 객체 생성 -> 의존 설정 -> 초기화 -> 사용 -> 소멸 과정

**빈 등록 방법**
- ComponentScan 이용
- `@Configuration`의 `@Bean` 사용해서 빈 설정파일에 등록

## <a id="4">Bean의 scope에 대해 설명하라</a>
> 빈이 존재할 수 있는 범위. 싱글톤, 프로토타입, request, session, application

- 싱글톤: 기본 스코프. 스프링 컨테이너 시작부터 종료까지 유지되는 가장 넓은 범위
- 프로토타입: 빈 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위 스코프
- request: 웹 요청 들어오고 나갈 때까지 유지
- session: 웹 세션 생성, 종료할 때까지
- application: 웹 서블릿 컨텍스트와 같은 범위로 유지

## <a id="5">IoC 컨테이너의 역할?</a>
>  애플리케이션 실행 시점에 빈 객체를  인스턴스화하고 DI한 후에 최초로 애플리케이션을 기동할 빈 하나를 제공

## <a id ="6">DI 종류는 어떤 것이 있고 이들의 차이는 무엇인가?</a>
> 생성자 주입, setter 주입, 필드 주입

- 생성자 주입: 생성자 호출 시점에 딱 1번 호출 보장. 불변, 필수 의존관계에 사용. 순환의존 방지가능.
- setter 주입:
- 필드 주입: `@Autowired`를 사용. 테스트하기 힘듦. 테스트코드나 설정할 때 씀.

## <a id="7">Autowiring 과정에 대해 설명하라</a>
1. 컨테이너에서 타입을 이용해 빈(객체) 검색
2. 할당할 수 있는 빈 객체를 찾아 주입함


## <a id="8">@Bean과 @Component 차이</a>
**`@Bean`**
- `@Configuration` 할 때 사용
- 개발자가 직접 객체 생성, 구성 제어해야할 때. 직접 빈의 생성, 초기화 과정 제어해야할 때.

**`@Component`**
- 클래스 수준에서  사용. component-scan 기능이 이거 발견하면 클래스의 인스턴스를 빈으로 등록
- 개발자가 직접 정의한 클래스에 빈 자동으로 등록하고 싶을 때.

## <a id="9">DispatcherServlet의 동작 원리에 대해 설명하라</a>

## <a id="10">프론트 컨트롤러 패턴이란 무엇인가?</a>
> 웹 애플리케이션의 요청을 중앙 집중식으로 처리

**장점**
- 클라이언트의 요청마다 서블릿을 만들어서 쓰면 개발, 유지보수 효율 떨어짐
- 요청에 대한 처리 로직을 한 곳에서 관리할 수 있어서 코드 구조 깔끔해짐
- 프론트 컨트롤러는 요청 처리하고 적절한 뷰 선택해서 사용자에게 응답
- 중앙에서 요청 처리하니까 사용자 인증, 권한 체크 같은 보안 로직도 한 곳에서 관리 가능
- 인터셉터 구현도 쉬워짐: 전처리, 후처리 로직 쉽게 추가 가능

**스프링의 프론트 컨트롤러 패턴**
`DispatcherServlet`은 웹 앱에서 클라ㅏ이언트의 모든 요청을 최초로 받아들이는 컨트롤러 역할임.  
동작 방식
1. 요청 수신: 요청을 맨 앞단에서 DispatcherServlet이 받음
2. 핸들러 매핑: 요청 처리할 컨트롤러(핸들러) 찾음.
3. 컨트롤러  실행
4. 뷰 리졸루션: 컨트롤러 실행 결과로 리턴된 뷰 이름 기반으로 실제 뷰 찾는 뷰 리졸버 메커니즘 동작
5. 뷰 렌더링: 하고 나서 클라에게 최종 응답으로 전송됨

## <a id="11">Servlet Filter와 Spring Interceptor의 차이점은 무엇인가?</a>
둘다 전후처리 수행하는 구성요소인데...
**Filter**
> `javax.servlet` 스펙에 포함되는 클래스

- Servlet에서 전후처리 담당이니까 웹 애플리케이션에서 실행되는 모든 종류의 요청에 대해 작동. 정적 리소스 요청(CSS, JS, 이미지)에도 작동함.
- 웹 애플리케이션에 등록(톰캣이면 web.xml)
- 요청 .. 인코딩 설정... 로깅...
- 실행시점: `DispatcherServlet`이 처리하기 전후에 실행

**Interceptor**
> Spring MVC 스펙에 포함되는 클래스

- 스프링에서 핸들러 실행 전후 처리 담당이니까 스프링 프레임워크 구조 내에서만 동작. `DispatcherServlet`을 통해 처리되는 요청만. 
- 스프링의 `ApplicationContext`에 등록
- 스프링 앱에서 전역적으로 전후처리 로직에서 예외 사용하게 하거나, 핸들러 메소드에서 사용자 권한 체크해서 다른 동작 시켜준다거나
- 실행시점: `DispatcherServlet`이 컨트롤러 호출하기 전후

## <a id="12">Spring에서 CORS 에러 해결하는 방법을 설명하라</a>
- 스프링 시큐리티에서 CorsConfigurationSource를 빈으로 등록하고 config에 추가하여 해결
- 혹은 컨트롤러 클래스에 `@Crossorigin` 어노테이션을 붙여 해결

## <a id="13">Lombok이 만드는 메소드들이 생성되는 시점은?</a>
- 컴파일하는 과정에 개입하여 추가적인 코드를 만들어냄. 이걸 **어노테이션 프로세싱** 이라고 함.
- 좀 더 자세히 찾아보기.

## <a id="14">@Transactional의 동작 원리는?</a>
- AOP를 통해 타겟이 상속하고 있는 인터페이스 또는 타겟 객체를 상속한 프록시 객체가 생성됨
- 프록시 객체의 메소드를 호출하면 타겟 메소드 전, 후 시점에 트랜잭션 처리 수행
- 단, 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작. 타겟 객체가 자기 자신의 다른 메소드를 호출할 때는 프록시가 동작하지 않음.

## <a id="15">스프링에서 요청마다 스레드가 생성되어 컨트롤러를 통해 요청 수행하는데 어떻게 1개의 컨트롤러만 생성되는가?</a>
- `@Controller`도 내부적으로는 `@Component`임. 따라서 IoC 컨테이너에 등록되어 스프링 빈으로 관리됨.
- 스프링 빈 생성 전략은 기본적으로 싱글톤임. 애플리케이션이 초기화되는 시점에 초기화됨.
- 요청 시마다 새로 빈 생성하는게 아니라 이미 생성된 빈을 가져다 쓰는 거임.

## <a id="16">스프링의 서블릿 구성 방식?</a>
기본적으로 자바의 서블릿은 하나의 요청에 대해 하나의 서블릿을 생성함. 간단하긴 한데 서블릿이 많이 생성되면 관리하기 힘들어짐. 반면 스프링은 `DispatcherServlet`이라는 **Front Controller** 패턴 사용. 하나의 서블릿이 요청을 받아 `HandlerMapping` 통해 그에 맞는 컨트롤러로 분배함. 

## <a id="17">스프링 애플리케이션 구동할 때 메소드를 실행시키는 방법</a>
- CommandLineRunner, ApplicationRunner 구현한 클래스 만들기
- ApplicationEvent 사용하기
- @PostConstruct
- InitializingBean 인터페이스 구현하기
- @Bean의 initMethod 사용하기
