## 목차  
[Spring DI/IOC는 어떻게 동작하는가?](#1)

## <a id="1">Spring DI/IOC는 어떻게 동작하는가?</a>
### IoC(제어의 역전)
> 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것. 코드의 최종 호출을 개발자가 아닌 프레임워크 내부에서 결정된 대로 이뤄짐

- 내 생각: 내가 일일히 의존성주입 안해줘도 됨 객체 생명주기 관리 안해줘도 되고 내가 하면 실수 연발일 듯
- 모듈화 가능?

### DI(의존성 주입)
> 스프링에서 지원하는 IoC의 형태. 클래스 사이 의존관계를 빈 설정 정보 바탕으로 컨테이너가 자동으로 연결

## <a id="2">Spring Bean이란 무엇인가?</a>
> IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC 컨테이너에서 가져와서 사용  

`@Bean`을 사용해서 일반 객체를 Bean으로 등록 가능

## <a id="3">Bean의 생성 과정을 설명하라</a>
> 객체 생성 -> 의존 설정 -> 초기화 -> 사용 -> 소멸 과정

**빈 등록 방법**
- ComponentScan 이용
- `@Configuration`의 `@Bean` 사용해서 빈 설정파일에 등록

## <a id="4">Bean의 scope에 대해 설명하라</a>
> 빈이 존재할 수 있는 범위. 싱글톤, 프로토타입, request, session, application

- 싱글톤: 기본 스코프. 스프링 컨테이너 시작부터 종료까지 유지되는 가장 넓은 범위
- 프로토타입: 빈 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위 스코프
- request: 웹 요청 들어오고 나갈 때까지 유지
- session: 웹 세션 생성, 종료할 때까지
- application: 웹 서블릿 컨텍스트와 같은 범위로 유지

## <a id="5">IoC 컨테이너의 역할?</a>
>  애플리케이션 실행 시점에 빈 객체를  인스턴스화하고 DI한 후에 최초로 애플리케이션을 기동할 빈 하나를 제공

## <a id ="6">DI 종류는 어떤 것이 있고 이들의 차이는 무엇인가?</a>
> 생성자 주입, setter 주입, 필드 주입

- 생성자 주입: 생성자 호출 시점에 딱 1번 호출 보장. 불변, 필수 의존관계에 사용. 순환의존 방지가능.
- setter 주입:
- 필드 주입: `@Autowired`를 사용. 테스트하기 힘듦. 테스트코드나 설정할 때 씀.

## <a id="7">Autowiring 과정에 대해 설명하라</a>
1. 컨테이너에서 타입을 이용해 빈(객체) 검색
2. 할당할 수 있는 빈 객체를 찾아 주입함


## <a id="8">@Bean과 @Component 차이</a>
**`@Bean`**
- `@Configuration` 할 때 사용
- 개발자가 직접 객체 생성, 구성 제어해야할 때. 직접 빈의 생성, 초기화 과정 제어해야할 때.

**`@Component`**
- 클래스 수준에서  사용. component-scan 기능이 이거 발견하면 클래스의 인스턴스를 빈으로 등록
- 개발자가 직접 정의한 클래스에 빈 자동으로 등록하고 싶을 때.

## <a id="9">DispatcherServlet의 동작 원리에 대해 설명하라</a>

## <a id="10">프론트 컨트롤러 패턴이란 무엇인가?</a>
