
## <a id="1">N+1 문제 발생하는 이유, 해결 방법?</a>
> N+1이란, 1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것.

- 원인은, 연관관계 있는 엔티티 조회할 때 한 쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문(필요한 곳에서 각각 쿼리가 발생)
- 해결은 **Fetch Join** 으로. 두 테이블을 조인하여 한 번에 가져옴.
- **즉시 로딩 시** : JPQL 쓸 때 영속성 컨텍스트가 아닌 DB에서 직접 조회한 다음 즉시로딩 전략이 동작해서
- **지연 로딩 시** : 하위 엔티티 로드할 때 JPA에서 프록시 엔티티를 unproxy할 때 해당 엔티티 조회하기 위한 추가적인 쿼리가 실행되어 발생함

## <a id="2">JPA와 하이버네이트의 차이점?</a>
- **JPA** : ORM에 대한 기본적인 기능, API를 정의한 표준 스펙
- **Hibernate** : JPA의 표준 구현체 중 하나. 

## <a id="3">하이버네이트에서 세션과 트랜잭션의 역할은?</a>
**세션**
> 하이버네이트에서 DB와의 연결을 나타내는 객체임. 클라이언트 요청에 따라 생성됨.

- 세션은 영속성 컨텍스트 관리함.
- 일반적으로 요청, 작업 단위로 생성되고 사용 끝나면 종료됨.
- 좀 더 찾아보자.

**트랜잭션**
- DB 상태 변경하는 작업 단위.
- 하나의 세션 내에 여러 트랜잭션이 존재 가능.

## <a id="4">엔티티의 라이프 사이클?</a>
1. 비영속 상태: 생성되었지만 영속성 컨텍스트에 저장되지 않음. 엔티티의 `@Id`가 할당되지 않은 상태.
2. 영속 상태: 영속성 컨텍스트에 의해 관리되는 상태. `persist()` 호출하면 이 상태가 됨. 이 상태에서 엔티티의 변경사항 더티체킹.
3. 준영속 상태: 영속성 컨텍스트에서 분리된 상태. `detach()` 호출. 더티체킹 안됨.
4. 삭제 상태: `remove()`호출. 삭제 대상으로 표시됨. 영속성 컨텍스트에 존재하긴 하는데 더이상 사용 못 함.

## <a id="5">엔티티의 상태 전이는 어떻게 이루어지는가?</a>
**비영속 -> 영속**
- `persist()` 호출.
- 영속성 컨텍스트에 저장되며 DB에 INSERT 쿼리 실행됨.
- `@Id`도 할당.

**영속->준영속**
- `detach()` 호출
- 더이상 변경사항 추적되지 않음
- 영속성 컨텍스트가 종료되거나 `clear()` 호출되면 모든 영속상태의 엔티티가 준영속 상태로 전이됨.

**영속->삭제**
- `remove()` 호출
- 트랜잭션 커밋 시 DELETE 쿼리 실행됨

**준영속->영속**
- `merge()` 호출
- 엔티티의 변경사항이 영컨에 반영됨. 트랜잭션 커밋 시 UPDATE 쿼리 실행.

## <a id="6">persist(), flush() 차이?</a>
`persist()`  
- 새 엔티티를 영속성 컨텍스트에 **추가**
- 영속 상태로 전이됨
- 실제 DB에 INSERT 쿼리가 실행되는 건 아니고, 트랜잭션 커밋 시점이나 `flush()` 호출될 때까지 지연됨

`flush()`  
- 영속성 컨텍스트의 변경 내용을 DB에 동기화하는 역할.
- 호출 시점에 변경 사항이 DB에 즉시 반영됨.
- 트랜잭션 커밋 시점에 자동으로 호출됨.
- 영속성 컨텍스트를 비우지 않고, 변경사항만 DB에 반영하는 것임.
- 필요한 경우에만 호출하는게 일반적. 예를들어 JPQL 쿼리 실행 전에 변경사항 반영해야하는 경우에 호출.

일반적으로, `persist()` 호출 뒤에 명시적으로 `flush()` 호출할 필요 없음. 트랜잭션 커밋 시점에 자동으로 호출되니까.  

## <a id="7">JPA에서 엔티티를 캐시하는 방법은 무엇인가?</a>
**1차 캐시**
> 영속성 컨텍스트 내에서 엔티티를 캐시하는 방법

- 영속성 컨텍스트는 엔티티 매니저와 일대일로 연결되어 있으며, 엔티티 매니저를 통해 엔티티 조회, 변경할 때 1차 캐시 사용됨
- 1차 캐시는 엔티티 매니저 내부에 존재. 함께 생성되고 함께 사라짐.
- 엔티티 조회할 때 먼저 1차 캐시에서 찾고, 없으면 DB에서 조회해 1차 캐시에 저장.
- 1차 캐시는 트랜잭션 범위 내에서 유효. 트랜잭션 종료되면 1차 캐시도 사라짐.

**2차 캐시**
> 애플리케이션 수준에서 엔티티를 캐시하는 방법

- 여러 영속성 컨텍스트 간에 공유됨. 애플리케이션 전체에서 사용 가능.
- 주로 읽기 연산 많은 경우에 사용됨. DB 접근 횟수 줄여 성능 향상 가능.
- JPA 표준에서는 2차 캐시에 대한 인터페이스만 제공. 구현체는 별도의 캐시 프로바이더 써야됨. (EhCache, Redis) 설정도 따로 해줘야됨.
- 엔티티 클래스에 `@Cacheable` 추가해서 2차 캐시에 저장.
- 선택적으로 쓰는 거임.

## <a id="8">쿼리 캐시에 대해?</a>
> 실행된 쿼리 결과 캐시해서 동일한 쿼리 다시 실행될 때 DB 대신 캐시에서 결과 가져옴.

- 읽기 연산 많고 변경 드문 경우에 효과적.
- 2차 캐시와 함께 쓰면 더 효과적임. 

## <a id="9">JPA에서 프록시란 무엇인가?</a>
> JPA에서 프록시는 연관된 엔티티를 지연로딩할 때 사용하는 객체.

- 엔티티 조회할 때, 연관 엔티티가 지연 로딩이면 실제 엔티티 대신 프록시 객체가 리턴됨.
- 프록시 객체의 메소드나 속성에 접근할 때 실제 엔티티가 로딩됨.

## <a id="10">JPA의 상속 전략에 대해?</a>
**싱글 테이블**
> 말 그대로 부모와 자식 필드를 하나의 테이블에 다 때려 박는 것.
- 조인 안해도 돼서 성능 좋음.
- 자식의 필드가 nullable이어야 함. 컬럼 수 개많아짐.

**Tabel per concrete class**
> 부모와 자식을 각각 개별 테이블에 매핑
- 부모 속성이 자식 테이블에 포함됨.
- 조회 시 조인 필요. 데이터 중복 발생 가능.

**Joined**
> 부모, 자식을 각각 개별 테이블에 매핑하는데 부모 필드는 부모에, 자식 필드는 자식에. 자식은 부모의 기본키를 외래키로 가짐.
- 테이블 정규화가 잘 되어 있음.
- 조인 필요. 쿼리 복잡.

