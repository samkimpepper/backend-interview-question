
## 목차
- [메소드 오버라이딩이란 무엇인가?](#1)
- [오버라이딩, 오버로딩 메소드에서 예외를 다룰 때 주요 제한 사항은 무엇인가?](#2)
- [슈퍼클래스의 오버라이드된 메소드를 서브클래스의 오버라이딩 메소드에서 어떻게 호출할 수 있는가?](#3)
- [main 메소드를 오버라이드 또는 오버로드할 수 있는가?](#4)
- [자바에서 static이 아닌 메소드를 static 메소드로 오버라이드할 수 있는가?](#5)
- [자바 인터페이스 안에 abstract가 아닌 메소드를 포함할 수 있는가?](#6)
- [default 메소드를 갖는 인터페이스와 추상클래스의 주요 차이점은 무엇인가?](#7)


## <a id="1">메서드 오버라이딩이란 무엇인가?</a>
> 같은 이름과 시그니처를 가지면서 다르게 동작하는 메소드

  - private, static, final 메소드는 오버라이드할 수 없음
  - 오버라이딩 메소드는 오버라이드된 메소드에 의해 발생한 확인된 예외(checked exception)보다 `Exception` 클래스 계층구조에서 상위에 있는 예외 발생시킬 수 없음  


  
## <a id="2">오버라이딩, 오버로딩 메소드에서 예외를 다룰 때 주요 제한 사항은 무엇인가?</a>

### 오버라이드 메소드
- Unchecked Exception: 제한 없음
- Checked Exception: 오버라이드된 메소드에서 발생된 예외보다 넓은 범위를 가진 예외 발생 불가
  - 예) 오버라이드된 메소드가 `SQLException` 발생시킨다면 오버라이딩 메소드는 `BatchUpdateException` 같은 서브클래스 예외는 발생시킬 수 있지만 Exception 같은 슈퍼클래스 예외는 발생 불가
### 오버로딩 메소드
- 제한 없음

## <a id="3">슈퍼클래스의 오버라이드된 메소드를 서브클래스의 오버라이딩 메소드에서 어떻게 호출할 수 있는가?</a>
> 자바의 `super` 키워드로 호출 가능

## <a id="4">main 메소드를 오버라이드 또는 오버로드할 수 있는가?</a>
> 오버라이드 불가능, 오버로드 가능  
- main 메소드는 `static` 메소드임. `static` 메소드는 컴파일 타임에 결정되지만 오버라이드는 런타임에 결정되기 때문에 오버라이드 불가능.

## <a id="5">자바에서 static이 아닌 메소드를 static 메소드로 오버라이드할 수 있는가?</a>
> 불가능. 반대의 경우도 불가능.

## <a id="6">자바 인터페이스 안에 abstract가 아닌 메소드를 포함할 수 있는가?</a>
### 자바 8 이전
- 불가능
### 자바 8부터
- 가능
- `default`, `static` 키워드 써서 구현된 메소드 추가 가능

## <a id="7">default 메소드를 갖는 인터페이스와 추상클래스의 주요 차이점은 무엇인가?</a>
### 인터페이스
- 생성자 지원 안 함
- 상태 가질 수 없음
- 완전히 추상화된 상태 구현이 목표 (이게 뭔 뜻이야) -> 다양한 기능 합성? can-do
- 인터페이스가 `default` 메소드만 갖는 것은 안티 패턴
### 추상 클래스
- 생성자 지원
- 상태 가질 수 있음
- 부분적인 추상화가 목적 -> is-a 관계에 기반한 공통 기능의 기본 구현
- 추상 메소드가 없어도 문제 없음
아직 두 개의 목적 차이를 잘 모르겠음

## <a id="8>컬렉션 프레임워크에 대해 설명하라</a>
> 데이터를 저장하고 관리하기 위한 표준화된 인터페이스와 그 구현 제공

- `Collection`: 모든 컬렉션의 최상위 인터페이스. 기본 연산 정의
- `List`: 순서대로 요소 저장. 중복 허용.
- `Set`: 중복 비허용. 순서 보장하지 않음.
- `Queue`: 요소가 입력되고 출력되는 순서를 중요시
- `Deque`
- `Map`: 키 중복 불가
**주요 구현 클래스**
- `ArrayList`, `LinkedList`, `LinkedHashSet`, `TreeSet`, `PriorityQueue`, `HashMap`, `LinkedHashMap`
### 향상된 for문과의 호환성!
- 컬렋녀 클래스들은 `Iterable` 인터페이스를 구현하므로 향상된 for문 사용 가능
### 스레드 안전성
- 스레드 안전하지 않음. 동시성 고려 설계된 컬렉션들은 `java.util.concurrent` 패키지에서 제공
### null
- 일부 컬렉션은 Null 요소 허용하지 않음 : `TreeSet`, `TreeMap`

## <a id="9">제네릭에 대해 설명하라</a>
> 자바의 타입 안정성. 컴파일 과정에서 타입 체크를 함. 제네릭을 쓰면 데이터 타입 미리 지정하지 않고 파라미터로 전달 가능

- 타입 안정성: 컴파일 시점에 타입 에러 체크. 런타임 에러 가능성 줄어듦
- 코드 재사용성: 하나의 코드를 여러 타입에 대해 동작하도록 작성 가능해서 편함
- 타입 캐스팅 제거: 제네릭 안 쓰면 객체 읽어올 때 매번 적절한 타입으로 캐스팅해야됨
- 제한된 타입 파라미터: 타입 파라미터에 제한 둘 수도 있음. 특정 클래스의 하위 클래스만 허용하게 하기 -> `class Example<T extends SomeClass>`
- 와일드카드: 제네릭 타입의 미정상태 표현하는 와일드카드`?`. List<?>는 모든 타입의 리스트.
- 타입 소거: 자바 제네릭은 컴파일 시점에만 존재. 런타임에는 제네릭 타입 정보 제거됨. 하위호환성 유지 위함. 런타임에는 제네릭이 적용되지 않은 일반 객체로 취급

### `List<T>`와 `List<?>`의 차이점
- 와일드카드 타입은 읽기만 가능. 쓰기는 불가능. 알 수 없는 타입의 List를 나타낸다는데 무슨 소린지 모르겠음.특정한 타입에 제한되지 않도록 한다고?

## <a id="10">어노테이션에 대해 설명하라</a>
> 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미 부여하거나 기능 주입 가능.

- 커스텀 어노테이션 만들려면 `@interface` 키워드 사용
- 어노테이션의 요소는 메소드의 형태로 정의되며 파라미터를 가질 수 없음
- 메타 어노테이션: 어노테이션 선언할 때 사용
- 

## <a id="11">static이란 무엇인가?</a>
> 클래스 멤버(클래스 수준에서 공유되는 멤버)라고 함. 인스턴스에 종속되지 않고 클래스 자체에 속하게 됨. 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리됨

- static 키워드로 생성된 정적 멤버들은 PermGen or Metaspace에 저장됨
- 클래스 로드 시점에 메모리에 할당. 
- 저장된 메모리는 모든 객체가 공유. 하나의 멤버를 어디에서든 참조할 수 있는 장점.
- 단점: GC의 관리 영역 밖에 존재. 프로그램 종료시까지 메모리 할당된 채로 존재함. 

